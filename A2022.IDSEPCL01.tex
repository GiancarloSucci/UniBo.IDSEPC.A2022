 \documentclass{beamer}
%
% Choose how your presentation looks.
% For more themes, color themes and font themes, see:
% http://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html
%
\mode<presentation>
{
  \usetheme{Madrid}      % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{seahorse} % or try albatross, beaver, crane, ...
  \usefonttheme{serif}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
  \usepackage{amsmath}
  \usepackage{tcolorbox}
  \usepackage[export]{adjustbox}
  \tcbuselibrary{most}
  \usepackage{arydshln}
 %\usepackage{enumitem}
%\usepackage{enumerate}
  %\usepackage[shortlabels]{enumitem}
} 


\definecolor{myblue}{RGB}{65,105,225} 
\definecolor{myorange}{RGB}{250,190,0}

\setbeamercolor{structure}{fg=white,bg=myorange}
\setbeamercolor*{palette primary}{fg=myblue,bg=myorange}
\setbeamercolor*{palette secondary}{fg=white,bg=myblue}
\setbeamercolor*{palette tertiary}{bg=myblue,fg=white}
\setbeamercolor*{palette quaternary}{fg=white,bg=myorange!50}

\setbeamercolor{frametitle}{fg=black!90!myblue}

\setbeamercolor{section in head/foot}{fg=white,bg=myblue}
\setbeamercolor{author in head/foot}{fg=black,bg=myorange}
\setbeamercolor{title in head/foot}{fg=white,bg=myblue}

\setbeamertemplate{navigation symbols}{}

\defbeamertemplate*{headline}{mytheme}
{%
  \begin{beamercolorbox}[ht=2.25ex,dp=3.75ex]{section in head/foot}
    \insertnavigation{\paperwidth}
  \end{beamercolorbox}%
}%

\defbeamertemplate*{footline}{mytheme}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,right]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor\hspace*{2em}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,left]{title in head/foot}%
    \usebeamerfont{title in head/foot}\hspace*{2em}\insertshortsubtitle\hspace*{2em}
    \insertframenumber{} / \inserttotalframenumber
  \end{beamercolorbox}}%
  \vskip0pt%
}



\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{pgf}  
\usepackage{textpos}
\usepackage{tabulary}
\usepackage{scrextend}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{rotating}
\lstset
{
    language=[LaTeX]TeX,
    breaklines=true,
    basicstyle=\tt\scriptsize,
    %commentstyle=\color{green}
    keywordstyle=\color{blue},
    %stringstyle=\color{black}
    identifierstyle=\color{magenta},
}

\usepackage{stackengine}
\def\Ruble{\stackengine{.67ex}{%
  \stackengine{.48ex}{\textsf{P}}{\rule{.8ex}{.12ex}\kern.6ex}{O}{r}{F}{F}{L}%
  }{\rule{.8ex}{.12ex}\kern.6ex}{O}{r}{F}{F}{L}\kern-.1ex}



%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------
%\logo{\pgfbox[top]{\includegraphics[width=1.6cm]{logo-iu.png}}}
\title[L01]{Lezione 1: Introduzione alla data science e al pensiero computazionale} % The short title appears at the bottom of every slide, the full title is only on the title page

\author[{\tiny Giancarlo Succi }]{Giancarlo Succi } % Your name
\institute[unibo] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space

\date{Week 01 - Lecture

Chapter 1.1-1.4 \& 1.8, C} % Date, can be changed to a custom date
%\pgfdeclareimage[width=2.5cm]{logo}{logo-iu.png}
%\logo{\pgfuseimage{logo}{\vspace{10pt}}}

\setbeamertemplate{navigation symbols}{}
\AtBeginSection[]
{
        \begin{frame}<beamer>{Outline}
                \tableofcontents[currentsection]
        \end{frame}
}
\begin{document}
\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}

%=============================================

\addtobeamertemplate{frametitle}{}{%
\begin{textblock*}{10mm}(-0.01mm,-1cm)
\includegraphics[width=0.9cm]{unibo-logo.png}
\end{textblock*}}

%=============================================
\begin{frame}
{\centerline{Sources}}
\begin{itemize}
    \item These slides have been adapted from the original slides of the adopted book: 
    \begin{itemize}
    \item Tanenbaum \& Bos, Modern  Operating Systems: 4th edition, 2013 Prentice-Hall, Inc.
    \end{itemize}
    and customised for the needs of this course.
    \item Additional input for the slides are detailed later
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{Outline}}
\begin{itemize}
    \item What is OS
    \item Kernel mode \& User mode
    \item OS as Extended Machine and Resource Manager 
    \item History of OS(1st-5th Generations)
    \item Computer Hardware Review (Processors, Memory, Disks, I/O, busses)
    \item Booting the Computer
    \item OS Zoo
\end{itemize} 
\end{frame}


\begin{frame}
{\centerline{What is Operating System?}}
The OS is a layer of software that:
\begin{itemize}
    \item Provides user programs with a better, simpler, cleaner model of the computer
    \item Handles managing all the resources
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{Kernel mode \& User mode}}
\begin{itemize}
    \item Most computers have two modes of operation: kernel mode and user mode
\end{itemize}

\begin{figure}[htp]
    \centering
     \input{tikz/pictureL01.tikz}
\end{figure}
\end{frame}


\begin{frame}
{\centerline{Kernel mode}}

The operating system runs in kernel mode (also called supervisor mode):
\begin{itemize}
    \item has complete access to all the hardware
    \item can execute any instruction the machine is capable of %executing
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{User mode}}
\begin{itemize}
    \item The rest of the software runs in user mode:
    \begin{itemize}
        \item Only a subset of the machine instructions is available \\
        \item The instructions that affect control of the machine or do I/O (Input/Output) are forbidden to user-mode programs \\
        \item To obtain services from the OS, a user program must make a system call(TRAP), which traps into the kernel and invokes the OS \\
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{The OS as an Extended Machine}}
\begin{itemize}
    \item Top-down view
    \begin{itemize}
        \item Problem:
        \begin{itemize}
            \item hardware is very complicated and presents difficult and inconsistent interfaces to the software developers
        \end{itemize}
        \item Solution:
        \begin{itemize}
            \item use abstractions, for instance, a disk driver, that deals with the hardware and provides an interface to read and write disk blocks
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{The OS as a Resource Manager(1/2)}}
\begin{itemize}
    \item Bottom-up view
    \begin{itemize}
        \item Manage all the pieces of a complex system
        \item The job of the operating system is to provide for an orderly and controlled allocation of the processors, memories, and I/O devices among the various programs wanting them
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{The OS as a Resource Manager(2/2)}}
\begin{itemize}
    \item Multiplexing(sharing) resources can be done in two ways:
    \begin{itemize}
        \item Time multiplexing
        \begin{itemize}
            \item different programs or users take turns using it (example: CPU, printers)
        \end{itemize}
        \item Space multiplexing
        \begin{itemize}
            \item instead of the customers taking turns, each one gets part of the resource(example:memory, disks)
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{1945-1955 - The 1st Generation.}\\
     \centerline{Vacuum tubes, plug boards}}
\begin{columns}
\begin{column}{0.5\linewidth}
  \begin{itemize}
    \item Colossus by Alan Turing
    \item ENIAC by WIlliam Mauchley
    \begin{itemize}
        \item No OS
        \item  Slow \& Huge
        \item Large air conditioner
        \item High electricity consumption
        \item Limited storage capacity
        \item Programmed in mechanical language
    \end{itemize}
\end{itemize}
\end{column}
\begin{column}{0.5\linewidth}
\begin{figure}
    \centering
   \includegraphics[width=0.8\textwidth]{Pictures/slide11.png}
\end{figure}
\end{column}
\end{columns}
\end{frame}


\begin{frame}
{\centerline{1955-1965 - The 2nd Generation}}
\begin{itemize}
    \item Transistors and Batch Systems/Mainframes
    \begin{itemize}
        \item Transistors
        \item Core Memory - developed
        \item Faster than the 1st generation
        \item First Operating System
        \item Programming was in Machine Language \& Assembly
        \item Magnetic tapes \& disks were used
        \item Computers became smaller than the 1st generation
        \item Computers generated less heat and consumed less electricity
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{1965-1980 - The 3rd Generation}}
\begin{columns}
\column{0.5\textwidth}
\begin{itemize}
    \item Transistors and Batch Systems/Mainframes
    \begin{itemize}
        \item Integrated Circuits
        \item Multiprogramming
        \item Spooling
        \item Timesharing
    \end{itemize}
    \item Examples:
    \begin{itemize}
        \item IBM System/360
    \end{itemize}
\end{itemize}
\column{0.5\textwidth}
\begin{figure}
    \centering
   \includegraphics[width=0.8\textwidth]{Pictures/slide13.png}
\end{figure}
\end{columns}
\end{frame}



\begin{frame}
{\centerline{1965-1971 - The 3rd Generation. 1 Part.}}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{itemize}
    \item Part 1. Integrated circuits
    \begin{itemize}
        \item Integrated circuits developed
        \item Power consumption was low
        \item SSI \& MSI Technology was used
        \item High level languages were used
    \end{itemize}
    \item Example:
    \begin{itemize}
        \item Honeywell-6000 series
        \item PDP(Personal Data Processor)
        \item IBM-360 and 370/168 series
        \item TDC-316
    \end{itemize}
\end{itemize}
\end{column}
\begin{column}{0.5\textwidth}
\begin{figure}
    \centering
    \includegraphics[width=.8\textwidth]{Pictures/slide14.png}
\end{figure}
\end{column}
\end{columns}

\end{frame}


\begin{frame}
{\centerline{1971-1980 - The 3rd Generation. 2 Part.}}
\begin{itemize}
    \item Part 2. Microprocessors
    \begin{itemize}
        \item LSI \& VLSI Technology used
        \item Development of Portable Computers
        \item RAID Technology of data storage
        \item Used in virtual reality, multimedia, simulation
        \item Computers started in use for Data Communication
        \item Different types of memories with very high accessing speed & storage capacity
    \end{itemize}
    \item Used in: parallel processing, superconductors, speech recognition, intelligent robots, artificial intelligence
\end{itemize}
\end{frame}



\begin{frame}
{\centerline{1980-1990 - The 4th Generation.} \\\centerline{Personal Computers}}
\begin{itemize}
    \item Personal computers were developed after LSI (Large Scale Integration) circuits were invented.
    \item First Microcomputer:
    \begin{itemize}
        \item Intel 8080 CPU + attached 8-inch floppy disk
        \item First disk based OS CP/M (Control Program for Microcomputers)
    \end{itemize}
    \item In 1980s, IBM designed the IBM PC and contacted Bill Gates for an operating System
\end{itemize}
\end{frame}



\begin{frame}
{\centerline{1990- Present - The 5th Generation.} \\ \centerline{Mobile Computers}}
\begin{figure}
    \centering
    \includegraphics[width=.8\textwidth]{Pictures/slide17.png}
\end{figure}
\end{frame}



\begin{frame}
{\centerline{Computer Hardware}}
\begin{itemize}
    \item An OS is tied to the hardware of the computer it runs on. It extends the computer’s instruction set and manages its resources
    \begin{itemize}
        \item Processors
        \item Main memory
        \item Disks
        \item I/O devices
        \item Buses
    \end{itemize}
\end{itemize}
\begin{figure}
    \centering
    \input{tikz/pictureL02.tikz}
\end{figure}
\end{frame}


\begin{frame}
{\centerline{Processors(1/7)}}
\begin{itemize}
    \item The basic cycle of every CPU:
    \begin{itemize}
        \item \textbf{Fetch Instruction} - read next expected instruction into buffer
        \item\textbf{Decode Instruction} - determine opcode & operand specifiers 
        \item \textbf{Calculate Operands} - calculate the effective address of each source operand
        \item \textbf{Fetch Operands} - fetch each operand from memory. Operands in registers need not be fetched
        \item \textbf{Execute Instruction} - perform the indicated operation and store the result
        \item \textbf{Write Operand} - store the result in memory
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{Processors (2/7)}}
\begin{itemize}
    \item CPU contains some registers inside to hold key variables and temporary results:
    \begin{itemize}
        \item \textbf{General registers} - hold variables and temporary results
        \item \textbf{Program counter }- contains the address of next instruction to be fetched
        \item \textbf{Stack pointer} - points to the current stack in memory 
        \item \textbf{PSW (Program Status Word)} - bits of results of comparison instructions, the CPU priority, the mode (kernel or user) and various other control bits
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{Processors (3/7)}}
\begin{enumerate}[label=(\Alph*)]
    \item A three-stage pipeline (Figure 1.7)
    \begin{figure}
        \input{tikz/pictureL03.tikz}
    \end{figure}
    \item A superscalar CPU (Figure 1.7)
        \begin{figure}
        \input{tikz/pictureL04.tikz}
    \end{figure}
\end{enumerate}
\end{frame}


\begin{frame}
{\centerline{Processors (4/7) - Multithreading}}
\begin{itemize}
    \item Multithreading or hyper-threading
    \begin{itemize}
        \item It allows the CPU to hold the state of two different threads and then switch between them in nanoseconds
        \item If one of the processes needs to read a word from memory (long operation), a multithreaded CPU can just switch to another thread thus saving time 
        \item Multithreading does not offer true parallelism
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{Processors (5/7) - Multithreading}}
Multithreading or hyper-threading
\begin{figure}
    \centering
    \input{tikz/pictureL05.tikz}
\end{figure}
\end{frame}


\begin{frame}
{\centerline{Processors (6/7) - Multithreading}}
\begin{itemize}
    \item Many CPU chips now have some complete processors or cores. Making use of such a multicore chip will require a multiprocessor OS
    \begin{itemize}
        \item A modern GPU (Graphics Processing Unit) is a processor with thousands of tiny cores which are very good for many small computations done in parallel, like rendering polygons in graphics applications
        \item Multicore chips do true parallelism
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{Processors (7/7) - Multicore Chips}}
\begin{enumerate}[label=(\Alph*)]
    \item a) A quad-core chip with a shared L2 cache
    \item b) A quad-core chip with separate L2 caches
\end{enumerate}

\centering
\input{tikz/pictureL06.tikz}
\end{frame}


\begin{frame}
{\centerline{Memory (1/7)}}
The memory system is  constructed as a hierarchy of layers. The top layers have higher speed, smaller capacity, and greater cost per bit than the lower ones
\begin{figure}
    \centering
    \input{tikz/pictureL07.tikz}
\end{figure}
\end{frame}


\begin{frame}
{\centerline{Memory (2/7)}}
Main memory is divided up into cache lines, typically 64 bytes. The most heavily used cache lines are kept in a high-speed cache located inside the CPU
\end{frame}


\begin{frame}
{\centerline{Memory (3/7)}}
\begin{itemize}
    \item When the program needs to read a memory word, the cache hardware checks to see if the line needed is in the cache. If it is (a cache hit), no memory request is sent over the bus to the main memory. It normally takes about 2 clock cycles 
    \item Some machines have two or even three levels of cache, each one slower and bigger than the one before it
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{Memory (4/7)}}
\begin{itemize}
    \item Caching system issues:
    \begin{itemize}
        \item When to put a new item into the cache
        \item Which cache line to put the new item in 
        \item Which item to remove from the cache when a slot is needed
        \item Where to put a newly evicted item in the larger memory
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{Memory (5/7) - Caching}}
\begin{itemize}
    \item RAM (Random-Access Memory) serves all CPU requests that cannot be satisfied out of the cache
    \begin{figure}
        \centering
        \includegraphics[width=.7\textwidth]{Pictures/slide29.png}
    \end{figure}
    \item ROM (Read-Only Memory) does not lose its contents
when the power is switched off, is programmed at the factory and cannot be changed afterward. On some computers, the bootstrap loader used to start the computer is contained in ROM
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{Memory (6/7) - Main Memory}}
\begin{itemize}
    \item EEPROM (Electrically Erasable Programmable ROM) and flash memory are also nonvolatile, but in contrast to ROM can be erased and rewritten  
    \item Flash memory is also commonly used as the storage medium in portable electronic devices. It is intermediate in speed between RAM and disk plus it wears out
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{Memory (7/7) - Main Memory}}
\begin{itemize}
    \item Many computers use complementary metal-oxide-semiconductor (CMOS) memory to hold the current time, date and the configuration parameters, such as which disk to boot from.
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{Disks (1/2)}}
\begin{columns}
\begin{column}{.5\linewidth}\centering
\begin{itemize}
    \item Multi-platter HDD
    \begin{itemize}
        \item Platters
        \item Actuator arm
        \item Read/write head 
        \item Segment – an arc on the track
        \item Track
        \item Sector
    \end{itemize}
\end{itemize}
\end{column}
\begin{column}{.5\linewidth}\centering
\includegraphics[width=.7\textwidth]{Pictures/slide33.png}\par 
\end{column}
\end{columns}
\end{frame}


\begin{frame}
{\centerline{Disks (2/2)}}
\begin{itemize}
    \item Time to read/write from disk consists of
    \begin{itemize}
        \item \textbf{Seek time }is a physical positioning of read/write head
        \item \textbf{Rotation delay (latency)} is the amount of time it takes for the disc to rotate to the required position for the read/write head
        \item \textbf{Transfer time (data rate)} is the amount of time it takes for data to be read or written
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{I/O Devices (1/7)}}
\begin{itemize}
    \item Generally consist of two parts:
    \begin{itemize}
        \item a controller that accepts commands from the operating system and carries them out
        \item a device itself that has fairly simple interfaces, both because they cannot do much and to make them standard
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{I/O Devices (2/7)}}
\begin{itemize}
    \item Device driver is a software that talks to a controller, giving it commands and accepting responses. It has to be put into the OS so it can run in kernel mode 
    \item Every controller has a small number of registers that are used to communicate with it. The collection of all the device registers forms the \textbf{I/O port space}
    \item On some computers, the device registers are mapped into the operating system’s address space (the addresses it can use), so they can be read and written like ordinary memory words
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{I/O Devices (3/7)}}
\begin{itemize}
    \item On other computers, the device registers are put in a special I/O port space, with each register having a port address. On these machines, special IN and OUT instructions are available in kernel mode to allow drivers to read and write the registers 
    \item Input and output can be done in three different ways:
    \begin{itemize}
        \item Busy waiting:
        \begin{itemize}
            \item the driver starts the I/O and sits in a tight loop continuously polling the device to see if it is done. It has the disadvantage of tying up the CPU polling the device until it is finished
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{I/O Devices (4/7) - Busy Waiting}}
\begin{itemize}
    \item Interrupt:
    \begin{itemize}
        \item The driver starts the device and asks it to give an interrupt when it is finished. The operating system then blocks the caller if need be and looks for other work to do
        \item When the controller detects the end of the transfer, it generates an interrupt to signal completion. The device number may be used as an index into part of memory to find the address of the interrupt handler for this device. This part of memory is called \textbf{the interrupt vector}
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{I/O Devices (5/7) - Interrupts}}
\begin{enumerate}
    \item The steps in starting an I/O device and getting an interrupt
    \item Interrupt processing involves taking the interrupt, running the interrupt handler, and returning to the user program
\end{enumerate}
\begin{figure}
    \centering
    \input{tikz/pictureL08.tikz}
\end{figure}
\end{frame}

\begin{frame}
{\centerline{I/O Devices (6/7) - DMA}}
\begin{itemize}
    \item Direct Memory Access (DMA):
    \begin{itemize}
        \item DMA is a chip that can control the flow of bits between memory and some controller without constant CPU intervention
        \item The CPU programs the DMA chip, telling it what and where to transfer and lets it go. When the DMA chip is done, it causes an interrupt, which is handled as described above
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{I/O Devices (7/7) - DMA}}
\begin{figure}
    \centering
    \input{tikz/pictureL09.tikz}
\end{figure}
\end{frame}

\begin{frame}
{\centerline{Buses (1/5)}}
\begin{itemize}
    \item The system has many buses, each with a different transfer rate and function. The OS must be aware of all of them for configuration and management.
    \item A shared bus architecture means that multiple devices use the same wires to transfer data which needs an arbiter to determine who can use the bus.
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{Buses (2/5)}}
\begin{itemize}
    \item A parallel bus architecture means that you send each word of data over multiple wires. For instance, in regular PCI buses, a single 32-bit number is sent over 32 parallel wires.
    \begin{figure}
        \centering
        \input{tikz/pictureL10.tikz}
    \end{figure}
    \item A serial bus architecture sends all bits in a message through a single connection, known as a lane. Parallelism is still used, because you can have multiple lanes in parallel (send 32 messages via 32 lanes).
    \begin{figure}
        \centering
        \input{tikz/pictureL11.tikz}
    \end{figure}
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{Buses (3/5)}}
\begin{itemize}
    \item Double Data Rate (DDR3, DDR4) connects CPU and RAM
    \item Peripheral Component Interconnect (PCIe) is a bus to an external graphical device
    \item Direct Media Interface (DMI) is a link between north bridge and south bridge - a hub for all the other devices
    \item SCSI, SATA - connects hard disks
\end{itemize}

\end{frame}

\begin{frame}
{\centerline{Buses (4/5)}}
\begin{itemize}
    \item Universal Serial Bus (USB) is a centralized bus in which a root device polls all the I/O devices to see if they have any traffic.
\end{itemize}
\begin{figure}
    \centering
    \includegraphics[width=0.3\textwidth]{Pictures/slide45.png}
\end{figure}
\end{frame}

\begin{frame}
{\centerline{Buses (5/5) - Plug \& Play}}
\begin{itemize}
    \item Before plug and play, each I/O card had a fixed interrupt request level and fixed addresses for its I/O registers. And two different pieces of hardware might use the same interrupt, so they will conflict
    \item Plug and play makes the system automatically collect information about the I/O devices, centrally assign interrupt levels and I/O addresses, and then tell each card what its numbers are
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{Booting the Computer (1/5)}}
\begin{itemize}
    \item \textbf{Basic Input Output System (BIOS)} is a program on the parent board that contains low-level I/O software.
    \item After the BIOS is started it performs \textbf{Power-On Self-Test (POST)} to test integrity and see how much RAM is installed and other basic devices are installed and responding correctly.
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{Booting the Computer (2/5)}}
\begin{itemize}
    \item It starts out by scanning the buses to detect all the devices attached to them. Then it determines the boot device by trying a list of devices stored in the CMOS memory
    \item CMOS (Complementary metal–oxide–semiconductor) is a technology for constructing integrated circuits
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{Booting the Computer (3/5)}}
\begin{itemize}
    \item The boot sector (first sector from the boot device) is read into memory and executed. This sector contains a program that normally examines the partition table at the end of the boot sector to determine which partition is active
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{Booting the Computer (4/5)}}
\begin{itemize}
    \item\textbf{ A secondary boot loader }is read in from that partition. This loader reads in the OS from the active partition and starts it. The OS then queries the BIOS to get the configuration information. For each device, it checks to see if it has the device driver.
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{Booting the Computer (5/5)}}
\begin{itemize}
    \item Once it has all the device drivers, the OS loads them into the kernel. Then it initializes its tables, creates whatever background processes are needed, and starts up a login program or GUI
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{The OS Zoo (1/2)}}
\begin{itemize}
    \item Mainframe Operating Systems
    \begin{itemize}
        \item Example: OS/390, OS/360
    \end{itemize}
    \item Server Operating Systems
    \begin{itemize}
        \item Example: UNIX, Windows 2000, Linux
    \end{itemize}
    \item Multiprocessor Operating Systems
    \item Personal Computer Operating Systems
    \begin{itemize}
        \item Examples: Windows 98, XP, Mac OS, Linux
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{The OS Zoo (2/2)}}
\begin{itemize}
    \item Handheld Computer Operating Systems
    \item Embedded Operating Systems
    \item Sensor Node Operating Systems
    \item Real-Time Operating Systems 
    \item Smart Card Operating Systems
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{Mainframe Operating Systems}}
\begin{itemize}
    \item Mainframes are room-sized computers in data centers. The operating systems for mainframes are heavily oriented toward processing many jobs at once, most of which need prodigious amounts of I/O
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{Mainframe Operating Systems}}
\begin{itemize}
    \item Typically kinds of service:
    \begin{itemize}
        \item A \textbf{batch }system processes routine jobs without any interactive user present
        \item \textbf{Transaction-processing }systems handle large numbers of small requests
        \item \textbf{Timesharing} systems allow multiple remote users to run jobs on the computer at once, such as querying a big database
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{Server Operating System}}
\begin{itemize}
    \item They run on servers, which are either very large personal computers, workstations, or even mainframes. They serve multiple users at once over a network and allow the users to share hardware and software resources.
    \item Examples: Solaris, FreeBSD, Linux, Windows Server.
\end{itemize}
\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{Pictures/slide55.png}
\end{figure}
\end{frame}


\begin{frame}
{\centerline{Multiprocessor Operating Systems}}
\begin{itemize}
    \item Connect multiple CPUs in a single system:
    \begin{itemize}
        \item parallel computers
        \item multicomputers
        \item multiprocessors
    \end{itemize}
    \item Nowadays all PC and notebooks OS deal with small-scale multiprocessors
    \begin{itemize}
        \item Examples: Linux, Windows
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{Personal Computer Operating Systems}}
\begin{itemize}
    \item You know what is it.
    \begin{itemize}
        \item Examples: FreeBSD, Linux, Mac OS X, Windows
    \end{itemize}
\end{itemize}
\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{Pictures/slide58.png}
\end{figure}
\end{frame}


\begin{frame}
{\centerline{Handheld Computer Operating Systems}}
\begin{itemize}
    \item OS for PDAs earlier and Mobile Devices nowadays
    \begin{itemize}
        \item Example: Google Android, Apple iOS
    \end{itemize}
\end{itemize}
\begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{Pictures/slide59.png}
\end{figure}
\end{frame}

\begin{frame}
{\centerline{Embedded Operating Systems}}
\begin{itemize}
    \item Run on the computers that control devices that are not generally thought of as computers and which do not accept user- installed software: microwave ovens, MP3 players, TV sets, cars, etc.
    \begin{itemize}
        \item Examples: Embedded Linux, QNX, VxWorks
    \end{itemize}
\end{itemize}
\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{Pictures/slide60.png}
\end{figure}
\end{frame}

\begin{frame}
{\centerline{Sensor-Node Operating Systems}}
\begin{itemize}
    \item Each sensor node is a real computer, with a CPU, RAM, ROM, and one or more environmental sensors 
    \item These nodes communicate with each other and with a base station using wireless communication
    \begin{itemize}
        \item Example: TinyOS
    \end{itemize}
\end{itemize}
\begin{figure}
    \centering
    \includegraphics[width=0.2\textwidth]{Pictures/slide61.png}
\end{figure}
\end{frame}

\begin{frame}
{\centerline{Real-time Operating Systems}}
\begin{itemize}
    \item \textbf{A hard real-time system} must provide absolute guarantees that a certain action will occur by a certain time.
    \item \textbf{A soft real-time system} is one where missing an occasional deadline, while not desirable, is acceptable and does not cause any permanent damage.
    \item Example: QNX
\end{itemize}
\begin{figure}
    \centering
    \includegraphics[width=0.3\textwidth]{Pictures/slide62.png}
\end{figure}
\end{frame}


\begin{frame}
{\centerline{Smart Card Operating Systems}}
\begin{itemize}
    \item The smallest operating systems run on smart cards, which are credit-card-sized devices  containing a CPU chip
    \item Java oriented smart cards - means that the ROM on the smart card holds an interpreter for the Java Virtual Machine (JVM). Java applets (small programs) are downloaded to the card interpreted by the JVM interpreter
\end{itemize}
\begin{figure}
    \centering
    \includegraphics[width=0.2\textwidth]{Pictures/slide63.png}
\end{figure}
\end{frame}

\begin{frame}
\Large{\centerline{End of lecture 1}}
\end{frame}

\begin{frame}
{\centerline{References(1/3)}}
\begin{itemize}
    \item Tanenbaum & Bos, ModernOperating Systems: 4th edition, 2013, Prentice-Hall,
Inc. \\
\end{itemize}
\end{frame}

\begin{frame}
{\centerline{References (2/3)}}
\begin{itemize}
\item \url{http://www.slideshare.net/chukidadiz/evolution-of-programming-languages-24938001} \\
\item \url{http://www.digibarn.com/collections/posters/tongues/} \\
\item \url{http://www.quicklycode.com/infographics\_posters/the-history-of-programming-languages-poster} \\
\item \url{https://www.youtube.com/watch?v=bGk9W65vXNA} \\
\item \url{https://prezi.com/0ifwtcl48iy\_/first-generation-1940-1956-vacuum-tubes/} \\
\item \url{http://www.slideshare.net/akiladj/2-history-the-generations-of-computer-history} \\
\end{itemize}
\end{frame}


\begin{frame}
{\centerline{References (3/3)}}
\begin{itemize}
\item \url{http://thapaprabin.blogspot.ru/2012/08/generation-of-computer.html} \\
\item \url{https://zuber01.wordpress.com/2012/06/30/computer-generation/} \\
\item \url{http://slideplayer.com/slide/6671114/} \\
\item \url{https://en.wikipedia.org/wiki/Instruction\_pipelining} \\
\item \url{https://en.wikibooks.org/wiki/IB/Group\_4/Computer\_Science/Computer\_Organisation} \\
\end{itemize}
\end{frame}

\end{document}
